package com.august.minesweep.ui

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewmodel.compose.viewModel
import kotlin.random.Random

// Game Configurations
const val GRID_SIZE = 8
const val MINE_COUNT = 10

/**
 * This code is generated by ChatGPT (25.02.11)
 */
class MineSweeperActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            MineSweeperScreen()
        }
    }
}

// Game State ViewModel
class MineSweeperViewModel : ViewModel() {
    var board by mutableStateOf(generateBoard())
        private set

    var gameOver by mutableStateOf(false)
        private set

    fun revealCell(row: Int, col: Int) {
        if (gameOver) return
        val cell = board[row][col]
        if (!cell.isRevealed) {
            cell.isRevealed = true
            if (cell.isMine) {
                gameOver = true
            } else if (cell.number == 0) {
                // Auto-reveal surrounding cells if empty
                revealSurroundingCells(row, col)
            }
        }
    }

    fun restartGame() {
        board = generateBoard()
        gameOver = false
    }

    private fun revealSurroundingCells(row: Int, col: Int) {
        val directions = listOf(-1 to -1, -1 to 0, -1 to 1, 0 to -1, 0 to 1, 1 to -1, 1 to 0, 1 to 1)
        for ((dx, dy) in directions) {
            val newRow = row + dx
            val newCol = col + dy
            if (newRow in 0 until GRID_SIZE && newCol in 0 until GRID_SIZE) {
                val neighbor = board[newRow][newCol]
                if (!neighbor.isRevealed && !neighbor.isMine) {
                    neighbor.isRevealed = true
                    if (neighbor.number == 0) {
                        revealSurroundingCells(newRow, newCol)
                    }
                }
            }
        }
    }
}

// Data Class for Cell
data class Cell(var isMine: Boolean = false, var number: Int = 0, var isRevealed: Boolean = false)

// Function to Generate Board with Mines and Numbers
fun generateBoard(): Array<Array<Cell>> {
    val board = Array(GRID_SIZE) { Array(GRID_SIZE) { Cell() } }

    // Place Mines Randomly
    repeat(MINE_COUNT) {
        var row: Int
        var col: Int
        do {
            row = Random.nextInt(GRID_SIZE)
            col = Random.nextInt(GRID_SIZE)
        } while (board[row][col].isMine) // Ensure unique mine placement

        board[row][col].isMine = true
    }

    // Calculate Numbers
    for (row in 0 until GRID_SIZE) {
        for (col in 0 until GRID_SIZE) {
            if (!board[row][col].isMine) {
                board[row][col].number = countAdjacentMines(board, row, col)
            }
        }
    }
    return board
}

// Count Mines Around a Cell
fun countAdjacentMines(board: Array<Array<Cell>>, row: Int, col: Int): Int {
    val directions = listOf(-1 to -1, -1 to 0, -1 to 1, 0 to -1, 0 to 1, 1 to -1, 1 to 0, 1 to 1)
    return directions.count { (dx, dy) ->
        val newRow = row + dx
        val newCol = col + dy
        newRow in 0 until GRID_SIZE && newCol in 0 until GRID_SIZE && board[newRow][newCol].isMine
    }
}

// UI
@Composable
fun MineSweeperScreen(viewModel: MineSweeperViewModel = viewModel()) {
    Column(
        modifier = Modifier.fillMaxSize().padding(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text(
            text = if (viewModel.gameOver) "Game Over! ☠️" else "Minesweeper",
            style = MaterialTheme.typography.headlineMedium
        )

        Spacer(modifier = Modifier.height(16.dp))

        GameBoard(viewModel)

        Spacer(modifier = Modifier.height(16.dp))

        Button(onClick = { viewModel.restartGame() }) {
            Text("Restart Game")
        }
    }
}

@Composable
fun GameBoard(viewModel: MineSweeperViewModel) {
    Column {
        for (row in 0 until GRID_SIZE) {
            Row {
                for (col in 0 until GRID_SIZE) {
                    CellView(
                        cell = viewModel.board[row][col],
                        onClick = { viewModel.revealCell(row, col) }
                    )
                }
            }
        }
    }
}

@Composable
fun CellView(cell: Cell, onClick: () -> Unit) {
    val cellColor = when {
        !cell.isRevealed -> Color.Gray
        cell.isMine -> Color.Red
        else -> Color.White
    }

    Box(
        modifier = Modifier
            .size(40.dp)
            .background(cellColor, shape = RoundedCornerShape(4.dp))
            .border(1.dp, Color.Black)
            .clickable(enabled = !cell.isRevealed, onClick = onClick),
        contentAlignment = Alignment.Center
    ) {
        if (cell.isRevealed) {
            Text(
                text = when {
                    cell.isMine -> "💣"
                    cell.number > 0 -> cell.number.toString()
                    else -> ""
                },
                style = MaterialTheme.typography.bodyMedium
            )
        }
    }
}

@Preview
@Composable
fun PreviewMineSweeper() {
    MineSweeperScreen()
}